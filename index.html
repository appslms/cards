<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Holographic Card</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        touch-action: manipulation; /* Prevents zoom on double tap on mobile */
      }
      .transform-style-preserve-3d {
        transform-style: preserve-3d;
      }
    </style>
</head>
  <body class="bg-white">
    <main class="flex flex-col items-center justify-center min-h-screen w-full p-4 overflow-hidden">
      <div 
        class="virtual-card-container relative rounded-3xl transition-transform duration-100 ease-out"
        style="width: 420px; height: 520px; transform: perspective(1500px) rotateX(0deg) rotateY(0deg);"
      >
        <div class="w-full h-full transform-style-preserve-3d rounded-3xl overflow-hidden shadow-xl">
          <!-- Layer 1: Card Artwork -->
          <img 
            src="assets/card.png"
            alt="Virtual Card" 
            class="absolute inset-0 w-full h-full object-cover rounded-3xl"
          />
          <!-- Layer 2: Holographic Effect Layer -->
          <div 
            class="holo-effect absolute inset-0 opacity-90 mix-blend-color-dodge" 
            style="
              background-image: conic-gradient(from 180deg at 50% 50%, #2a8af6 0deg, #a33cf3 70deg, #f05285 130deg, #f7d268 200deg, #81f7ab 270deg, #2a8af6 360deg);
              background-size: 300% 300%;
              mask-image: url(assets/mask.png);
              -webkit-mask-image: url(assets/mask.png);
              mask-size: cover;
              -webkit-mask-size: cover;
              mask-position: center;
              -webkit-mask-position: center;
            "
          ></div>
          <!-- Layer 3: Glare Effect -->
          <div class="glare-effect absolute inset-0 mix-blend-overlay"></div>
        </div>
      </div>
    </main>
    
    <script type="module">
      // --- Constants ---
      const MOUSE_MAX_ROTATION_X = 20;
      const MOUSE_MAX_ROTATION_Y = 30;
      const GYRO_MAX_ROTATION_X = 15;
      const GYRO_MAX_ROTATION_Y = 20;
      const SMOOTHING_FACTOR = 0.08;

      // --- DOM Element Selection ---
      const cardContainer = document.querySelector('.virtual-card-container');
      const holoEffect = cardContainer.querySelector('.holo-effect');
      const glareEffect = cardContainer.querySelector('.glare-effect');

      // --- State ---
      let rotation = { x: 0, y: 0 };
      let targetRotation = { x: 0, y: 0 };
      let initialOrientation = { beta: null, gamma: null };
      let isGyroActive = false;
      let animationFrameId = null;

      // --- Style Update Function ---
      const updateCardStyles = () => {
        const yMax = isGyroActive ? GYRO_MAX_ROTATION_Y : MOUSE_MAX_ROTATION_Y;
        const xMax = isGyroActive ? GYRO_MAX_ROTATION_X : MOUSE_MAX_ROTATION_X;

        const clampedY = Math.min(Math.max(rotation.y, -yMax), yMax);
        const clampedX = Math.min(Math.max(rotation.x, -xMax), xMax);

        const glareX = (clampedY / yMax) * 100 + 50;
        const glareY = (-clampedX / xMax) * 100 + 50;
        const holoX = 50 - (clampedY / yMax) * 40;
        const holoY = 50 - (-clampedX / xMax) * 40;
        
        cardContainer.style.transform = `perspective(1500px) rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`;
        holoEffect.style.backgroundPosition = `${holoX}% ${holoY}%`;
        glareEffect.style.background = `radial-gradient(circle at ${glareX}% ${glareY}%, hsla(0,0%,100%,0.4) 0%, hsla(0,0%,100%,0) 50%)`;
      };

      const updateLoop = () => {
        rotation.x += (targetRotation.x - rotation.x) * SMOOTHING_FACTOR;
        rotation.y += (targetRotation.y - rotation.y) * SMOOTHING_FACTOR;
        updateCardStyles();
        if (isGyroActive) {
            animationFrameId = requestAnimationFrame(updateLoop);
        }
      };

      // --- Event Handlers ---
      const handleMouseMove = (e) => {
        if (isGyroActive) return;

        const { clientX, clientY, currentTarget } = e;
        const { left, top, width, height } = currentTarget.getBoundingClientRect();
        const x = clientX - left;
        const y = clientY - top;
        
        rotation.y = MOUSE_MAX_ROTATION_Y * (x / width - 0.5);
        rotation.x = -MOUSE_MAX_ROTATION_X * (y / height - 0.5);
        updateCardStyles();
      };

      const handleMouseLeave = () => {
        if (isGyroActive) return;
        rotation = { x: 0, y: 0 };
        updateCardStyles();
      };

      const handleDeviceOrientation = (event) => {
        const { beta, gamma } = event;
        if (beta === null || gamma === null) return;
        
        if (initialOrientation.beta === null) {
            initialOrientation.beta = beta;
            initialOrientation.gamma = gamma;
        }

        const deltaBeta = beta - initialOrientation.beta;
        const deltaGamma = gamma - initialOrientation.gamma;
        
        targetRotation.x = Math.min(Math.max(-deltaBeta, -GYRO_MAX_ROTATION_X), GYRO_MAX_ROTATION_X);
        targetRotation.y = Math.min(Math.max(-deltaGamma, -GYRO_MAX_ROTATION_Y), GYRO_MAX_ROTATION_Y);
      };
      
      const enableGyro = () => {
          if (isGyroActive) return;
          isGyroActive = true;
          initialOrientation = { beta: null, gamma: null };
          rotation = { x: 0, y: 0 };
          targetRotation = { x: 0, y: 0 };
          
          window.addEventListener('deviceorientation', handleDeviceOrientation);
          
          if (animationFrameId) cancelAnimationFrame(animationFrameId);
          animationFrameId = requestAnimationFrame(updateLoop);
      };

      const tryEnableGyro = async () => {
        if (!('DeviceOrientationEvent' in window)) return; // Not supported

        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            // iOS 13+ requires user gesture for permission.
            // A one-time listener prompts the user on first interaction.
            const requestPermission = async () => {
                try {
                    const permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState === 'granted') {
                        enableGyro();
                    }
                } catch (error) {
                    console.error("Device orientation permission request failed:", error);
                }
            };
            document.body.addEventListener('click', requestPermission, { once: true });
            document.body.addEventListener('touchstart', requestPermission, { once: true });
        } else {
            // Non-iOS 13+ browsers (like Android) can enable directly.
            enableGyro();
        }
      };

      // --- Initialization ---
      const init = () => {
        // Set up mouse controls as a fallback
        if (cardContainer) {
          cardContainer.addEventListener('mousemove', handleMouseMove);
          cardContainer.addEventListener('mouseleave', handleMouseLeave);
        }

        // Attempt to enable gyroscope controls by default
        tryEnableGyro();
        
        updateCardStyles();
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    </script>
  </body>
</html>