<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive Holographic Card</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body {
        touch-action: manipulation; /* Prevents zoom on double tap on mobile */
      }
      .transform-style-preserve-3d {
        transform-style: preserve-3d;
      }
    </style>
</head>
  <body class="bg-white">
    <main class="flex flex-col items-center justify-center min-h-screen w-full p-4 overflow-hidden">
      <div 
        class="virtual-card-container relative rounded-3xl transition-transform duration-100 ease-out"
        style="width: 420px; height: 520px; transform: perspective(1166px) rotateX(0deg) rotateY(0deg);"
      >
        <div class="w-full h-full transform-style-preserve-3d rounded-3xl overflow-hidden shadow-xl">
          <!-- Layer 1: Card Artwork -->
          <img 
            src="assets/card.png"
            alt="Virtual Card" 
            class="absolute inset-0 w-full h-full object-cover rounded-3xl"
          />
          <!-- Layer 2: Holographic Effect Layer -->
          <div 
            class="holo-effect absolute inset-0 opacity-65 mix-blend-color-dodge" 
            style="
              background-image: conic-gradient(from 180deg at 50% 50%, #2a8af6 0deg, #a33cf3 70deg, #f05285 130deg, #f7d268 200deg, #81f7ab 270deg, #2a8af6 360deg);
              background-size: 160% 160%;
              mask-image: url(assets/mask.png);
              -webkit-mask-image: url(assets/mask.png);
              mask-size: cover;
              -webkit-mask-size: cover;
              mask-position: center;
              -webkit-mask-position: center;
            "
          ></div>
          <!-- Layer 3: Glare Effect -->
          <div class="glare-effect absolute inset-0 mix-blend-overlay"></div>
        </div>
      </div>
    </main>
    
    <script type="module">
      // --- Finalized Settings ---
      const settings = {
        perspective: 1166,
        smoothing: 0.20,
        mouseMaxRotX: 30,
        mouseMaxRotY: 25,
        gyroMaxRotX: 30, 
        gyroMaxRotY: 25,
        holoOpacity: 0.65,
        holoBgSize: 160,
        holoMoveFactor: 50,
        glareOpacity: 0.75,
        glareSize: 60,
      };

      // --- DOM Element Selection ---
      const cardContainer = document.querySelector('.virtual-card-container');
      const holoEffect = cardContainer.querySelector('.holo-effect');
      const glareEffect = cardContainer.querySelector('.glare-effect');

      // --- State ---
      let rotation = { x: 0, y: 0 };
      let targetRotation = { x: 0, y: 0 };
      let initialOrientation = { beta: null, gamma: null };
      let isGyroActive = false;
      let animationFrameId = null;

      // --- Style Update Function ---
      const updateCardStyles = () => {
        const yMax = isGyroActive ? settings.gyroMaxRotY : settings.mouseMaxRotY;
        const xMax = isGyroActive ? settings.gyroMaxRotX : settings.mouseMaxRotX;

        const clampedY = Math.min(Math.max(rotation.y, -yMax), yMax);
        const clampedX = Math.min(Math.max(rotation.x, -xMax), xMax);

        const glareX = (clampedY / yMax) * 100 + 50;
        const glareY = (-clampedX / xMax) * 100 + 50;
        const holoX = 50 - (clampedY / yMax) * settings.holoMoveFactor;
        const holoY = 50 - (-clampedX / xMax) * settings.holoMoveFactor;
        
        cardContainer.style.transform = `perspective(${settings.perspective}px) rotateX(${rotation.x}deg) rotateY(${rotation.y}deg)`;
        
        holoEffect.style.opacity = settings.holoOpacity;
        holoEffect.style.backgroundSize = `${settings.holoBgSize}% ${settings.holoBgSize}%`;
        holoEffect.style.backgroundPosition = `${holoX}% ${holoY}%`;
        
        glareEffect.style.background = `radial-gradient(circle at ${glareX}% ${glareY}%, hsla(0,0%,100%,${settings.glareOpacity}) 0%, hsla(0,0%,100%,0) ${settings.glareSize}%)`;
      };

      const updateLoop = () => {
        rotation.x += (targetRotation.x - rotation.x) * settings.smoothing;
        rotation.y += (targetRotation.y - rotation.y) * settings.smoothing;
        updateCardStyles();
        if (isGyroActive) {
            animationFrameId = requestAnimationFrame(updateLoop);
        }
      };

      // --- Event Handlers ---
      const handleMouseMove = (e) => {
        if (isGyroActive) return;

        const { clientX, clientY, currentTarget } = e;
        const { left, top, width, height } = currentTarget.getBoundingClientRect();
        const x = clientX - left;
        const y = clientY - top;
        
        rotation.y = settings.mouseMaxRotY * (x / width - 0.5);
        rotation.x = -settings.mouseMaxRotX * (y / height - 0.5);
        updateCardStyles();
      };

      const handleMouseLeave = () => {
        if (isGyroActive) return;
        rotation = { x: 0, y: 0 };
        updateCardStyles();
      };

      const handleDeviceOrientation = (event) => {
        const { beta, gamma } = event;
        if (beta === null || gamma === null) return;
        
        if (initialOrientation.beta === null) {
            initialOrientation.beta = beta;
            initialOrientation.gamma = gamma;
        }

        const deltaBeta = beta - initialOrientation.beta;
        const deltaGamma = gamma - initialOrientation.gamma;
        
        targetRotation.x = Math.min(Math.max(deltaBeta, -settings.gyroMaxRotX), settings.gyroMaxRotX);
        targetRotation.y = Math.min(Math.max(-deltaGamma, -settings.gyroMaxRotY), settings.gyroMaxRotY);
      };
      
      const enableGyro = () => {
          if (isGyroActive) return;
          isGyroActive = true;
          initialOrientation = { beta: null, gamma: null };
          rotation = { x: 0, y: 0 };
          targetRotation = { x: 0, y: 0 };
          
          window.addEventListener('deviceorientation', handleDeviceOrientation);
          
          if (animationFrameId) cancelAnimationFrame(animationFrameId);
          animationFrameId = requestAnimationFrame(updateLoop);
      };

      const tryEnableGyro = async () => {
        if (!('DeviceOrientationEvent' in window)) return;

        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            const requestPermission = async () => {
                try {
                    const permissionState = await DeviceOrientationEvent.requestPermission();
                    if (permissionState === 'granted') {
                        enableGyro();
                    }
                } catch (error) {
                    console.error("Device orientation permission request failed:", error);
                }
            };
            document.body.addEventListener('click', requestPermission, { once: true });
            document.body.addEventListener('touchstart', requestPermission, { once: true });
        } else {
            enableGyro();
        }
      };

      // --- Initialization ---
      const init = () => {
        if (cardContainer) {
          cardContainer.addEventListener('mousemove', handleMouseMove);
          cardContainer.addEventListener('mouseleave', handleMouseLeave);
        }
        tryEnableGyro();
        updateCardStyles();
      };

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        init();
      }
    </script>
  </body>
</html>